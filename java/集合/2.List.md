# 1.List接口介绍

`java.util.List` 继承接口`Colletion`,特点 是有序集合,存入顺序和取除顺序一致。



>```java
>public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable
>```

## 1.1接口常用方法

作为Colletion接口的子类,它除了继承`Colletion`接口中的方法外,还添加了根据索引来操作的方法。

* `public void add(int index, E element)` :将指定元素添加到,索引指定的位置上。(越界异常)

* ``public E get(int index)` :获取指定索引的元素

* `public E set(int index, E element)` ::用指定元素替换集合中指定位置的元素,返回值的更新前的元素。(越界异常)

* `public E remove(int index)` 移除指定位置的元素,返回被移除的元素

  > 继承的方法

* `size()` 返回该集合的元素个数
* `isEmpty()` 判断集合是否为空
* `boolean contains(Object o);` 是否包含某个对象
* `boolean add(E e)` 添加元素
* `boolean remove(Object o)` 删除元素
* `boolean containsAll(Collection<?> c)` 是否包含某个继承它的集合
* `boolean addAll(Collection<? extends E> c)` 合并一个集合
* `boolean removeAll(Collection<?> c)` 删除一个集合
* `default boolean removeIf(Predicate<? super E> filter) `lambda表达式删除元素
* `boolean retainAll(Collection<?> c)` 保留传入的集合,删除其他元素
* `void clear()` 清空集合
* `default Stream<E> stream()` 返回集合流

## 1.2ArrayList类

``java.util.ArrayList``集合存储数据用的是数组结构,元素查询快,增删慢(数组扩容),百分之七八十日常使用。

该集合使用的是一个`transient Object[] elementData; `数组用来装数据

`public ArrayList(int initialCapacity)` 初始化指定数组大小,如果不指定则为空数组

```java
public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
//private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
```



### 1.21 ArrayList 扩容

```java
 /**
     * Appends the specified element to the end of this list.
     *
     * @param e element to be appended to this list
     * @return <tt>true</tt> (as specified by {@link Collection#add})
     */
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
```



每次添加元素的时候都会调用 ensureCapacityInternal(size+1) 判断下一个元素的下标+1是否大于数组的长度length。

```java
private void ensureCapacityInternal(int minCapacity) { //minCapacity为下一个元素的计数,开始为0
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }
```



//如果数组为空则在默认10 和size+1 取最大值

```java
  private static int calculateCapacity(Object[] elementData, int minCapacity) {
      if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        }
        return minCapacity;
    }
   // private static final int DEFAULT_CAPACITY = 10; 默认容器初始量10
```



//然后就是最小容量和 数组长度相比较,如果最小容量大于数组容量,则需要扩容

```
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}
```



```java
 private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length; //开始0
        int newCapacity = oldCapacity + (oldCapacity >> 1);//除以2 扩容1.5 ,开始都是0
        if (newCapacity - minCapacity < 0) //0-10
            newCapacity = minCapacity; //赋值为10
        if (newCapacity - MAX_ARRAY_SIZE > 0)//如果超出容器最大承受容量,则扩充更大
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);// 扩容并且保留原来的数据
    }
```



## 1.3Vector 类

>Vector和 ArrayList 内容方法一样,只不过每个操作都加上了 synchronized 关键字,但是线程安全, 而ArrayList线程不安全



## 1.4 LinkedList

>
>
>```java
>public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable
>```

`java.util.LinkedList`集合数据存储的结构是双向链表结构链表结构。方便元素添加、删除的集合。

它内部维护了一个Node节点,专门用来存储数据的

```java
  private static class Node<E> {
        E item; //存储数据泛型
        Node<E> next; //下一个节点
        Node<E> prev; //上一个节点

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }

```



`内部类实现的迭代器`

```java
   /**
     * Adapter to provide descending iterators via ListItr.previous
     */
    private class DescendingIterator implements Iterator<E> {
        private final ListItr itr = new ListItr(size());
        public boolean hasNext() { //是否包含下一个
            return itr.hasPrevious();
        }
        public E next() { // 返回下个
            return itr.previous();
        }
        public void remove() { //删除
            itr.remove();
        }
    }

```





### 1.41常用方法

* ``public void addFirst(E e)`` 往头部添加元素

* `public void addLast(E e)`:将指定元素添加到此列表的结尾。

* `public E getFirst()` :返回第一个元素

* `public E getLast()` :返回最后一个元素

* `public E removeFirst()`:移除并返回此列表的第一个元素。

* `public E removeLast()`:移除并返回此列表的最后一个元素。

  > ​	继承的方法

* `size()` 返回该集合的元素个数
* `isEmpty()` 判断集合是否为空
* `boolean contains(Object o);` 是否包含某个对象
* `boolean add(E e)` 添加元素
* `boolean remove(Object o)` 删除元素
* `boolean containsAll(Collection<?> c)` 是否包含某个继承它的集合
* `boolean addAll(Collection<? extends E> c)` 合并一个集合
* `boolean removeAll(Collection<?> c)` 删除一个集合
* `default boolean removeIf(Predicate<? super E> filter) `lambda表达式删除元素
* `boolean retainAll(Collection<?> c)` 保留传入的集合,删除其他元素
* `void clear()` 清空集合
* `default Stream<E> stream()` 返回集合流



### 1.42 LinkedList 添加

```java
 public boolean add(E e) {
        linkLast(e);
        return true;
    }
// 默认将元素添加至尾部

```

```java
  /**
     * Links e as last element.
     */
    void linkLast(E e) {
        final Node<E> l = last;
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++; //操作次数
    }
```



**删除**

> ​	默认删除头部

```java
  /**
     * Links e as last element.
     */
    void linkLast(E e) {
        final Node<E> l = last;
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
    }
```

